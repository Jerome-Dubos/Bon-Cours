import React, { useState, useCallback, useMemo, memo } from 'react';
import { useTranslation } from 'react-i18next';
import {
  FaCalendar,
  FaClock,
  FaComments,
  FaEnvelope,
  FaPaperPlane,
  FaPhone,
  FaUser,
} from 'react-icons/fa';

import {
  ErrorNotification,
  SuccessNotification,
} from '../../../../../../components/UI/Notifications/src/components/NotificationsLibrarie';
import {
  createEmailRule,
  createMessageRule,
  createNameRule,
  createPhoneRule,
  createRequiredRule,
} from '../../utils/validationRules';
import './ContactForm.css';

/**
 * Composant ContactForm optimisé avec performances améliorées
 * @version 2.0.0
 * @author Bon Cours Team
 */

const ContactForm = memo(({
  onSubmit,
  submitText,
  loadingText,
  className = '',
  variant = 'full', // "full" ou "modal"
  showJoursHoraires = true,
  initialData = {},
  onSuccess,
  onError,
}) => {
  const { t } = useTranslation();

  // Utiliser les traductions par défaut si non fournies
  const defaultSubmitText = submitText || t('forms.contact.submit');
  const defaultLoadingText = loadingText || t('forms.contact.loading');
  
  const [formData, setFormData] = useState({
    nom: '',
    prenom: '',
    email: '',
    telephone: '',
    message: '',
    jours: [],
    horaires: [],
    preferenceContact: 'email',
    ...initialData,
  });

  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [successNotifications, setSuccessNotifications] = useState([]);
  const [errorNotifications, setErrorNotifications] = useState([]);
  const [nextNotificationId, setNextNotificationId] = useState(1);

  // Options mémorisées pour éviter les re-créations
  const joursOptions = useMemo(() => [
    {
      value: 'lundi',
      label: t('forms.contact.options.jours.lundi'),
      icon: null,
    },
    {
      value: 'mardi',
      label: t('forms.contact.options.jours.mardi'),
      icon: null,
    },
    {
      value: 'mercredi',
      label: t('forms.contact.options.jours.mercredi'),
      icon: null,
    },
    {
      value: 'jeudi',
      label: t('forms.contact.options.jours.jeudi'),
      icon: null,
    },
    {
      value: 'vendredi',
      label: t('forms.contact.options.jours.vendredi'),
      icon: null,
    },
    {
      value: 'samedi',
      label: t('forms.contact.options.jours.samedi'),
      icon: null,
    },
    {
      value: 'dimanche',
      label: t('forms.contact.options.jours.dimanche'),
      icon: null,
    },
  ], [t]);

  const horairesOptions = useMemo(() => [
    {
      value: 'matin',
      label: t('forms.contact.options.horaires.matin'),
      sublabel: t('forms.contact.options.sublabels.matin'),
      icon: null,
    },
    {
      value: 'apres-midi',
      label: t('forms.contact.options.horaires.apres_midi'),
      sublabel: t('forms.contact.options.sublabels.apres_midi'),
      icon: null,
    },
    {
      value: 'soir',
      label: t('forms.contact.options.horaires.soir'),
      sublabel: t('forms.contact.options.sublabels.soir'),
      icon: null,
    },
    {
      value: 'flexible',
      label: t('forms.contact.options.horaires.flexible'),
      sublabel: t('forms.contact.options.sublabels.flexible'),
      icon: null,
    },
  ], [t]);

  const preferenceOptions = useMemo(() => [
    {
      value: 'email',
      label: t('forms.contact.options.preference.email'),
      icon: FaEnvelope,
    },
    {
      value: 'telephone',
      label: t('forms.contact.options.preference.telephone'),
      icon: FaPhone,
    },
  ], [t]);

  // Fonction de validation optimisée avec useCallback
  const validateField = useCallback((field, value) => {
    let error = '';

    switch (field) {
      case 'nom':
        error = createRequiredRule()(value) || createNameRule()(value);
        break;
      case 'prenom':
        error = createRequiredRule()(value) || createNameRule()(value);
        break;
      case 'email':
        error = createRequiredRule()(value) || createEmailRule()(value);
        break;
      case 'telephone':
        // Le téléphone n'est obligatoire que si "Par téléphone" est sélectionné
        if (formData.preferenceContact === 'telephone') {
          error = createRequiredRule()(value) || createPhoneRule()(value);
        }
        break;
      case 'message':
        error = createRequiredRule()(value) || createMessageRule(10, 1000)(value);
        break;
      case 'preferenceContact':
        error = createRequiredRule()(value);
        break;
      case 'jours':
        if (formData.preferenceContact === 'telephone') {
          error = !value || value.length === 0 ? t('forms.contact.errors.select_jour') : '';
        }
        break;
      case 'horaires':
        if (formData.preferenceContact === 'telephone') {
          error = !value || value.length === 0 ? t('forms.contact.errors.select_creneau') : '';
        }
        break;
      default:
        break;
    }

    return error;
  }, [formData.preferenceContact, t]);

  // Gestionnaires d'événements optimisés avec useCallback
  const handleInputChange = useCallback((field, value) => {
    setFormData(prev => ({ ...prev, [field]: value }));

    // Effacer l'erreur si le champ a été touché
    if (touched[field]) {
      const error = validateField(field, value);
      setErrors(prev => ({ ...prev, [field]: error }));
    }
  }, [touched, validateField]);

  const handlePreferenceChange = useCallback((value) => {
    setFormData(prev => ({ ...prev, preferenceContact: value }));

    // Marquer comme touché et valider
    if (!touched.preferenceContact) {
      setTouched(prev => ({ ...prev, preferenceContact: true }));
    }

    // Réinitialiser les erreurs des champs conditionnels si nécessaire
    if (value !== 'telephone') {
      setErrors(prev => ({
        ...prev,
        telephone: '',
        jours: '',
        horaires: '',
      }));
    }

    const error = validateField('preferenceContact', value);
    setErrors(prev => ({ ...prev, preferenceContact: error }));
  }, [touched.preferenceContact, validateField]);

  const handleInputBlur = useCallback((field, value) => {
    setTouched(prev => ({ ...prev, [field]: true }));
    const error = validateField(field, value);
    setErrors(prev => ({ ...prev, [field]: error }));
  }, [validateField]);

  // Fonctions de notification optimisées avec useCallback
  const addNotification = useCallback((type, message) => {
    const newNotification = {
      id: nextNotificationId,
      message,
    };

    if (type === 'success') {
      setSuccessNotifications(prev => [...prev, newNotification]);
    } else if (type === 'error') {
      setErrorNotifications(prev => [...prev, newNotification]);
    }

    setNextNotificationId(prev => prev + 1);
  }, [nextNotificationId]);

  const removeSuccessNotification = useCallback((id) => {
    setSuccessNotifications(prev => prev.filter(n => n.id !== id));
  }, []);

  const removeErrorNotification = useCallback((id) => {
    setErrorNotifications(prev => prev.filter(n => n.id !== id));
  }, []);

  const handleJoursChange = useCallback((jour) => {
    setFormData(prev => {
      const newJours = prev.jours.includes(jour) 
        ? prev.jours.filter(j => j !== jour) 
        : [...prev.jours, jour];
      
      return { ...prev, jours: newJours };
    });

    // Marquer comme touché et valider
    if (!touched.jours) {
      setTouched(prev => ({ ...prev, jours: true }));
    }
    
    // Validation optimisée avec setTimeout pour éviter les conflits d'état
    setTimeout(() => {
      const error = validateField('jours', formData.jours);
      setErrors(prev => ({ ...prev, jours: error }));
    }, 0);
  }, [touched.jours, validateField, formData.jours]);

  const handleHorairesChange = useCallback((horaire) => {
    let newHoraires;

    // Calculer les nouveaux horaires
    if (horaire === 'flexible') {
      // Si on clique sur "flexible"
      if (formData.horaires.includes('flexible')) {
        // Si "flexible" était déjà sélectionné, on le désélectionne
        newHoraires = formData.horaires.filter(h => h !== 'flexible');
      } else {
        // Si "flexible" n'était pas sélectionné, on le sélectionne et on désélectionne tous les autres
        newHoraires = ['flexible'];
      }
    } else {
      // Si on clique sur un horaire autre que "flexible"
      if (formData.horaires.includes(horaire)) {
        // Si l'horaire était déjà sélectionné, on le désélectionne
        newHoraires = formData.horaires.filter(h => h !== horaire);
      } else {
        // Si l'horaire n'était pas sélectionné, on l'ajoute
        // Mais d'abord on retire "flexible" s'il était sélectionné
        const horairesSansFlexible = formData.horaires.filter(h => h !== 'flexible');
        newHoraires = [...horairesSansFlexible, horaire];

        // Vérifier si on a maintenant les 3 créneaux spécifiques (matin, après-midi, soir)
        const creneauxSpecifiques = ['matin', 'apres-midi', 'soir'];
        const creneauxSelectionnes = newHoraires.filter(h => creneauxSpecifiques.includes(h));

        if (creneauxSelectionnes.length === 3) {
          // Si les 3 créneaux spécifiques sont sélectionnés, on remplace par "flexible"
          newHoraires = ['flexible'];
        }
      }
    }

    // Mettre à jour l'état
    setFormData(prev => ({
      ...prev,
      horaires: newHoraires,
    }));

    // Marquer comme touché et valider avec les nouvelles valeurs
    if (!touched.horaires) {
      setTouched(prev => ({ ...prev, horaires: true }));
    }

    // Valider avec les nouvelles valeurs calculées
    const error = validateField('horaires', newHoraires);
    setErrors(prev => ({ ...prev, horaires: error }));
  }, [formData.horaires, touched.horaires, validateField]);

  // Fonctions de validation optimisées avec useCallback
  const validateForm = useCallback(() => {
    const newErrors = {};

    // Validation de tous les champs
    Object.keys(formData).forEach(field => {
      const error = validateField(field, formData[field]);
      if (error) {
        newErrors[field] = error;
      }
    });

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  }, [formData, validateField]);

  // Vérification optimisée de la validité du formulaire avec useMemo
  const isFormValid = useMemo(() => {
    // Champs toujours obligatoires
    if (
      !formData.nom.trim() ||
      !formData.prenom.trim() ||
      !formData.email.trim() ||
      !formData.message.trim()
    ) {
      return false;
    }

    // Validation des champs obligatoires
    const requiredFields = ['nom', 'prenom', 'email', 'message'];
    for (const field of requiredFields) {
      const error = validateField(field, formData[field]);
      if (error) return false;
    }

    // Si téléphone est sélectionné, validation des champs supplémentaires
    if (formData.preferenceContact === 'telephone') {
      if (!formData.telephone || formData.jours.length === 0 || formData.horaires.length === 0) {
        return false;
      }

      // Validation du téléphone
      const phoneError = validateField('telephone', formData.telephone);
      if (phoneError) return false;
    }

    return true;
  }, [formData, validateField]);

  // Fonction de soumission optimisée avec useCallback
  const handleSubmit = useCallback(async (e) => {
    e.preventDefault();

    if (!validateForm()) return;

    setIsSubmitting(true);

    try {
      // Si une fonction onSubmit est fournie, l'utiliser
      if (onSubmit) {
        const result = await onSubmit(formData);
        if (result) {
          // Afficher le message approprié selon le mode (simulation ou réel)
          const successMessage = result.simulated
            ? 'Votre message a été préparé avec succès. (Mode simulation)'
            : t('forms.contact.success');

          addNotification('success', successMessage);
          if (onSuccess) onSuccess(formData);

          // Reset form seulement si pas de reset personnalisé
          if (variant === 'full') {
            setFormData({
              nom: '',
              prenom: '',
              email: '',
              telephone: '',
              message: '',
              jours: [],
              horaires: [],
              preferenceContact: 'email',
            });
            setErrors({});
            setTouched({});
          }
        }
      } else {
        // Comportement par défaut
        await new Promise(resolve => setTimeout(resolve, 2000));

        addNotification('success', t('forms.contact.success'));

        // Reset form
        setFormData({
          nom: '',
          prenom: '',
          email: '',
          telephone: '',
          message: '',
          jours: [],
          horaires: [],
          preferenceContact: 'email',
        });

        // Reset des états de validation
        setErrors({});
        setTouched({});
      }
    } catch (error) {
      const errorMessage = error.message || t('forms.contact.error');
      addNotification('error', errorMessage);
      if (onError) onError(error);
    } finally {
      setIsSubmitting(false);
    }
  }, [validateForm, onSubmit, formData, addNotification, onSuccess, variant, t, onError]);

  return (
    <>
      <form className={`contact-form ${className}`} onSubmit={handleSubmit}>
        <div className={`contact-layout ${variant === 'modal' ? 'contact-layout--modal' : ''}`}>
          {/* Colonne gauche */}
          <div className='contact-column-left'>
            {/* Nom et Prénom */}
            <div className='contact-name-group'>
              <div className='contact-field'>
                <label className='contact-label'>
                  <FaUser className='contact-icon' />
                  {t('forms.contact.fields.nom')}
                </label>
                <input
                  type='text'
                  className={`contact-input ${errors.nom && touched.nom ? 'contact-error' : ''}`}
                  placeholder={t('forms.contact.placeholders.nom')}
                  value={formData.nom}
                  onChange={e => handleInputChange('nom', e.target.value)}
                  onBlur={e => handleInputBlur('nom', e.target.value)}
                />
                {errors.nom && touched.nom && (
                  <span className='contact-error-message'>{errors.nom}</span>
                )}
              </div>

              <div className='contact-field'>
                <label className='contact-label'>
                  <FaUser className='contact-icon' />
                  {t('forms.contact.fields.prenom')}
                </label>
                <input
                  type='text'
                  className={`contact-input ${
                    errors.prenom && touched.prenom ? 'contact-error' : ''
                  }`}
                  placeholder={t('forms.contact.placeholders.prenom')}
                  value={formData.prenom}
                  onChange={e => handleInputChange('prenom', e.target.value)}
                  onBlur={e => handleInputBlur('prenom', e.target.value)}
                />
                {errors.prenom && touched.prenom && (
                  <span className='contact-error-message'>{errors.prenom}</span>
                )}
              </div>
            </div>

            {/* Email */}
            <div className='contact-field'>
              <label className='contact-label'>
                <FaEnvelope className='contact-icon' />
                {t('forms.contact.fields.email')}
              </label>
              <input
                type='email'
                className={`contact-input ${errors.email && touched.email ? 'contact-error' : ''}`}
                placeholder={t('forms.contact.placeholders.email')}
                value={formData.email}
                onChange={e => handleInputChange('email', e.target.value)}
                onBlur={e => handleInputBlur('email', e.target.value)}
              />
              {errors.email && touched.email && (
                <span className='contact-error-message'>{errors.email}</span>
              )}
            </div>

            {/* Téléphone */}
            <div className='contact-field'>
              <label className='contact-label'>
                <FaPhone className='contact-icon' />
                {t('forms.contact.fields.telephone')}
              </label>
              <input
                type='tel'
                className={`contact-input contact-phone-input ${
                  errors.telephone && touched.telephone ? 'contact-error' : ''
                }`}
                placeholder='06 12 34 56 78'
                value={formData.telephone}
                onChange={e => handleInputChange('telephone', e.target.value)}
                onBlur={e => handleInputBlur('telephone', e.target.value)}
                style={{
                  backgroundColor: 'rgba(255, 255, 255, 0.08)',
                  border: '2px solid rgba(255, 255, 255, 0.15)',
                  borderRadius: '8px',
                  color: 'var(--text-light)',
                  padding: '16px 14px',
                  fontSize: '1rem',
                  outline: 'none',
                  transition: 'all 0.3s ease',
                }}
              />
              {errors.telephone && touched.telephone && (
                <span className='contact-error-message'>{errors.telephone}</span>
              )}
            </div>

            {/* Préférence de contact */}
            <div className='contact-field'>
              <label className='contact-label'>
                <FaPhone className='contact-icon' />
                {t('forms.contact.fields.preference_contact')}
              </label>
              <div className='contact-radio-group'>
                {preferenceOptions.map(option => (
                  <label
                    key={option.value}
                    className={`contact-radio-option ${
                      formData.preferenceContact === option.value ? 'contact-selected' : ''
                    }`}
                  >
                    <input
                      type='radio'
                      name='preferenceContact'
                      value={option.value}
                      checked={formData.preferenceContact === option.value}
                      onChange={e => handlePreferenceChange(e.target.value)}
                      className='contact-radio'
                    />
                    <div className='contact-radio-content'>
                      {option.icon && <option.icon className='contact-radio-icon' />}
                      <span className='contact-radio-label'>{option.label}</span>
                    </div>
                  </label>
                ))}
              </div>
              {errors.preferenceContact && touched.preferenceContact && (
                <span className='contact-error-message'>{errors.preferenceContact}</span>
              )}
            </div>
          </div>

          {/* Colonne droite */}
          <div className='contact-column-right'>
            {/* Message */}
            <div className='contact-field'>
              <label className='contact-label'>
                <FaComments className='contact-icon' />
                {t('forms.contact.fields.message')}
              </label>
              <textarea
                className={`contact-textarea ${
                  errors.message && touched.message ? 'contact-error' : ''
                }`}
                placeholder={t('forms.contact.placeholders.message')}
                value={formData.message}
                onChange={e => handleInputChange('message', e.target.value)}
                onBlur={e => handleInputBlur('message', e.target.value)}
                rows='6'
              />
              {errors.message && touched.message && (
                <span className='contact-error-message'>{errors.message}</span>
              )}
            </div>

            {/* Jours de préférence - Affiché si showJoursHoraires est true OU si téléphone est sélectionné */}
            {(showJoursHoraires || formData.preferenceContact === 'telephone') && (
              <div
                className={`contact-field contact-field-conditional ${
                  formData.preferenceContact === 'telephone' ? 'show' : ''
                }`}
              >
                <label className='contact-label'>
                  <FaCalendar className='contact-icon' />
                  {t('forms.contact.fields.jours_preference')}
                </label>
                <div className='contact-radio-group contact-horizontal'>
                  {joursOptions.map(option => (
                    <label
                      key={option.value}
                      className={`contact-radio-option ${
                        formData.jours.includes(option.value) ? 'contact-selected' : ''
                      }`}
                    >
                      <input
                        type='checkbox'
                        value={option.value}
                        checked={formData.jours.includes(option.value)}
                        onChange={() => handleJoursChange(option.value)}
                        className='contact-radio'
                      />
                      <div className='contact-radio-content'>
                        <span className='contact-radio-label'>{option.label}</span>
                      </div>
                    </label>
                  ))}
                </div>
                {errors.jours && touched.jours && (
                  <span className='contact-error-message'>{errors.jours}</span>
                )}
              </div>
            )}

            {/* Créneaux horaires - Affiché si showJoursHoraires est true OU si téléphone est sélectionné */}
            {(showJoursHoraires || formData.preferenceContact === 'telephone') && (
              <div
                className={`contact-field contact-field-conditional ${
                  formData.preferenceContact === 'telephone' ? 'show' : ''
                }`}
              >
                <label className='contact-label'>
                  <FaClock className='contact-icon' />
                  {t('forms.contact.fields.creneaux_horaires')}
                </label>
                <div className='contact-radio-group contact-horizontal'>
                  {horairesOptions.map(option => (
                    <label
                      key={option.value}
                      className={`contact-radio-option ${
                        formData.horaires.includes(option.value) ? 'contact-selected' : ''
                      }`}
                    >
                      <input
                        type='checkbox'
                        value={option.value}
                        checked={formData.horaires.includes(option.value)}
                        onChange={() => handleHorairesChange(option.value)}
                        className='contact-radio'
                      />
                      <div className='contact-radio-content'>
                        <span className='contact-radio-label'>{option.label}</span>
                        <span className='contact-radio-sublabel'>{option.sublabel}</span>
                      </div>
                    </label>
                  ))}
                </div>
                {errors.horaires && touched.horaires && (
                  <span className='contact-error-message'>{errors.horaires}</span>
                )}
              </div>
            )}

            {/* Bouton d'envoi */}
            <div className='contact-actions'>
              <button
                type='submit'
                className={`contact-submit-button ${isSubmitting ? 'contact-loading' : ''}`}
                disabled={isSubmitting || !isFormValid()}
              >
                {isSubmitting ? (
                  <>
                    <div className='contact-loading-spinner'></div>
                    {defaultLoadingText}
                  </>
                ) : (
                  <>
                    <FaPaperPlane className='contact-submit-icon' />
                    {defaultSubmitText}
                  </>
                )}
              </button>
            </div>
          </div>
        </div>
      </form>

      {/* Notifications de succès */}
      {successNotifications.length > 0 && (
        <SuccessNotification
          notifications={successNotifications}
          onRemove={removeSuccessNotification}
          autoClose={true}
          autoCloseDelay={4000}
          position='top-right'
          className='notification-compact'
        />
      )}

      {/* Notifications d'erreur */}
      {errorNotifications.length > 0 && (
        <ErrorNotification
          notifications={errorNotifications}
          onRemove={removeErrorNotification}
          autoClose={true}
          autoCloseDelay={5000}
          position='top-right'
          className='notification-compact'
        />
      )}
    </>
  );
};

// Ajout du displayName pour le debugging
ContactForm.displayName = 'ContactForm';

export default ContactForm;
